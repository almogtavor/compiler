import java_cup.runtime.*;
import Exceptions.SyntaxException;
import ast.*;


/*******************/
/* PARSER          */
/*******************/
parser code 
{:
    public Lexer lexer;
	public int errorLine = -1;
    public Parser(Lexer lexer)
    {
        super(lexer);
        this.lexer = lexer;
    }

    public void report_error(String message, Object info)
	{
		throw new SyntaxException(lexer.getLine());
	}

      public static int line(int l)
     {
        return l + 1;
     }
:}

/************************/
/*        SCANNER       */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	return s; 
:};
/*************/
/* TERMINALS */
/*************/
terminal IF;
terminal EQ;
terminal DOT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal WHILE;
terminal DIVIDE;
terminal LPAREN;
terminal RPAREN;
terminal LBRACK;
terminal RBRACK;
terminal LBRACE;
terminal RBRACE;
terminal SEMICOLON;
terminal ASSIGN;
terminal COMMA;
terminal LT;
terminal GT;
terminal ARRAY;
terminal CLASS;
terminal RETURN;
terminal ELSE;
terminal NEW;
terminal EXTENDS;
terminal NIL;
terminal TYPE_INT;
terminal TYPE_STRING;
terminal TYPE_VOID;
terminal Integer INT;
terminal String STRING;
terminal String ID;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal AstProgram program;
non terminal AstDecList dec_list;
non terminal AstDec dec;

non terminal AstType type;
non terminal AstVarDec varDec;
non terminal AstFuncDec funcDec;
non terminal AstClassDec classDec;
non terminal AstCField cField;
non terminal AstCFieldList cFieldListTail;
non terminal AstArrayTypedef arrayTypedef;

non terminal AstStmtList stmtList;
non terminal AstStmt stmt;

non terminal AstExp exp;
non terminal AstNew newExp;
non terminal AstCallExp callExp;
non terminal AstVar var;

non terminal AstArgList formalsOpt;
non terminal AstArgList formals;
non terminal AstArgList formalsTail;

non terminal String extendsOpt;

non terminal AstExpList argListOpt;
non terminal AstExpList argList;

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence nonassoc ASSIGN;
precedence left EQ;
precedence left LT, GT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence nonassoc LBRACK;
precedence nonassoc LPAREN;
precedence left DOT;

/************************/
/* START WITH: program */
/************************/
start with program;

/********************/
/* DERIVATION RULES */
/********************/

program ::= dec:d dec_list:dl
    {: RESULT = new AstProgram(new AstDecList(dl, d)); :}
    ;



dec_list ::= dec:d dec_list:dl
    {: RESULT = new AstDecList(dl, d); :}
    |
    /* empty */
    {: RESULT = null; :}
    ;

dec ::= varDec:v      {: RESULT = v; :}
     | funcDec:f      {: RESULT = f; :}
     | classDec:c     {: RESULT = c; :}
     | arrayTypedef:a {: RESULT = a; :}
     ;


type ::= TYPE_INT
            {: RESULT = new AstTypeInt(lexer.getLine()); :}
       | TYPE_STRING
            {: RESULT = new AstTypeString(lexer.getLine()); :}
       | TYPE_VOID
            {: RESULT = new AstTypeVoid(lexer.getLine()); :}
       | ID:id
            {: RESULT = new AstTypeClass(id,lexer.getLine()); :}
       ;


varDec ::= type:t ID:id SEMICOLON
              {: RESULT = new AstVarDec(t, id, null, t.getLine()); :}

         | type:t ID:id ASSIGN exp:e SEMICOLON
              {: RESULT = new AstVarDec(t, id, e, t.getLine()); :}

         | type:t ID:id ASSIGN newExp:n SEMICOLON
              {: RESULT = new AstVarDec(t, id, n, t.getLine()); :}
         ;


funcDec ::= type:t ID:id LPAREN formalsOpt:args RPAREN LBRACE stmtList:body RBRACE
    {: RESULT = new AstFuncDec(t, id, args, body, t.getLine()); :}
    ;


formalsOpt ::= /* empty */
                  {: RESULT = null; :}
             | formals:f
                  {: RESULT = f; :}
             ;

formals ::= type:t ID:id formalsTail:tl
    {: RESULT = new AstArgList(new AstFormal(t, id), tl); :}
    ;

formalsTail ::= COMMA type:t ID:id formalsTail:tl
    {: RESULT = new AstArgList(new AstFormal(t, id), tl); :}
              |
              /* empty */
              {: RESULT = null; :}
              ;


extendsOpt ::= /* empty */
                  {: RESULT = null; :}
             | EXTENDS ID:id
                  {: RESULT = id; :}
             ;

cField ::= varDec:v      {: RESULT = new AstCField(v); :}
         | funcDec:f     {: RESULT = new AstCField(f); :}
         ;

cFieldListTail ::= cField:f cFieldListTail:tl
                     {: RESULT = new AstCFieldList(f,tl); :}
                  | /* empty */
                     {: RESULT = null; :}
                  ;

classDec ::= CLASS:c ID:name extendsOpt:parent LBRACE cField:f cFieldListTail:tl RBRACE
    {: RESULT = new AstClassDec(name, parent, new AstCFieldList(f,tl), line(cleft)); :}
    ;


arrayTypedef ::= ARRAY:a ID:id EQ type:t LBRACK RBRACK SEMICOLON
    {: RESULT = new AstArrayTypedef(t, id, line(aleft)); :}
    ;


stmtList ::= stmt:s stmtList:sl
                {: RESULT = new AstStmtList(s, sl); :}
           | stmt:s
                {: RESULT = new AstStmtList(s, null); :}
           ;


stmt ::= varDec:vd
            {: RESULT = new AstStmtVarDec(vd, vd.getLine()); :}

       | var:v ASSIGN exp:e SEMICOLON
            {: RESULT = new AstStmtAssign(v, e, v.getLine()); :}

       | var:v ASSIGN newExp:n SEMICOLON
            {: RESULT = new AstStmtAssign(v, n, v.getLine()); :}

       | RETURN:r SEMICOLON
            {: RESULT = new AstStmtReturn(null, rleft); :}

       | RETURN:r exp:e SEMICOLON
            {: RESULT = new AstStmtReturn(e, e.getLine()); :}

       | IF LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE
            {: RESULT = new AstStmtIf(cond, body, cond.getLine()); :}

       | IF LPAREN exp:cond RPAREN LBRACE stmtList:tb RBRACE
         ELSE LBRACE stmtList:eb RBRACE
            {: RESULT = new AstStmtIfElse(cond, tb, eb, cond.getLine()); :}

       | WHILE LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE
            {: RESULT = new AstStmtWhile(cond, body, cond.getLine()); :}

       | callExp:c SEMICOLON
            {: RESULT = new AstStmtCall(c, c.getLine()); :}
       ;



var ::= ID:id
           {: RESULT = new AstVarSimple(id, lexer.getLine()); :}
      | var:v DOT ID:id
           {: RESULT = new AstVarField(v, id, lexer.getLine()); :}
      | var:v LBRACK exp:e RBRACK
           {: RESULT = new AstVarSubscript(v, e, lexer.getLine()); :}
      ;


callExp ::= ID:id LPAREN argListOpt:args RPAREN
               {: RESULT = new AstCallExp(null, id, args, lexer.getLine()); :}
          | var:v DOT ID:id LPAREN argListOpt:args RPAREN
               {: RESULT = new AstCallExp(v, id, args, lexer.getLine()); :}
          ;



argListOpt ::= /* empty */
                  {: RESULT = null; :}
             | argList:l
                  {: RESULT = l; :}
             ;

argList ::= exp:e
                {: RESULT = new AstExpList(e, null, e.getLine()); :}
          | exp:e COMMA argList:al
                {: RESULT = new AstExpList(e, al, e.getLine()); :}
          ;


newExp ::= NEW type:t
               {: RESULT = new AstNew(t, null,t.getLine()); :}
         | NEW type:t LBRACK exp:e RBRACK
               {: RESULT = new AstNew(t, e, e.getLine()); :}
         ;

exp ::= var:v
          {: RESULT = new AstExpVar(v, lexer.getLine()); :}

      | callExp:c
          {: RESULT = c; :}

      | LPAREN exp:e RPAREN
          {: RESULT = e; :}

      | exp:e1 PLUS   exp:e2
          {: RESULT = new AstExpBinop(e1, e2, AstExpBinop.OP_PLUS, lexer.getLine()); :}

      | exp:e1 MINUS  exp:e2
          {: RESULT = new AstExpBinop(e1, e2, AstExpBinop.OP_MINUS, lexer.getLine()); :}

      | exp:e1 TIMES  exp:e2
          {: RESULT = new AstExpBinop(e1, e2, AstExpBinop.OP_TIMES, lexer.getLine()); :}

      | exp:e1 DIVIDE exp:e2
          {: RESULT = new AstExpBinop(e1, e2, AstExpBinop.OP_DIVIDE, lexer.getLine()); :}

      | exp:e1 LT     exp:e2
          {: RESULT = new AstExpBinop(e1, e2, AstExpBinop.OP_LT, lexer.getLine()); :}

      | exp:e1 GT     exp:e2
          {: RESULT = new AstExpBinop(e1, e2, AstExpBinop.OP_GT, lexer.getLine()); :}

      | exp:e1 EQ     exp:e2
          {: RESULT = new AstExpBinop(e1, e2, AstExpBinop.OP_EQ, lexer.getLine()); :}

      | INT:i
          {: RESULT = new AstExpInt(i, lexer.getLine()); :}

      | MINUS INT:i
          {: RESULT = new AstExpInt(-i, lexer.getLine()); :}

      | STRING:s
          {: RESULT = new AstExpString(s, lexer.getLine()); :}

      | NIL
          {: RESULT = new AstExpNil(lexer.getLine()); :}
      ;


